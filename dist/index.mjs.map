{"version":3,"sources":["../src/utils/dom.ts","../src/utils/pageBreaks.ts","../src/core/DomContainer.ts","../src/utils/canvas.ts","../src/core/PdfGenerator.ts","../src/index.ts"],"names":["cloneNode","node","javascriptEnabled","_a","child","clone","canvas","cloneCanvas","createElement","tagName","options","className","innerHTML","style","el","scripts","i","applyStyles","element","styles","key","removeElementsByClassName","container","classNames","removeElementsByTagName","tagNames","elements","handlePageBreak","pageHeightPx","rules","clientRect","startPage","endPage","nPages","pad","_DomContainer","overlay","innerRatio","containerWidth","overlayStyle","containerStyle","excludeClassNames","excludeTagNames","DomContainer","isCanvasBlank","blank","ctx","drawPdfPage","sourceCanvas","pageNumber","pageCanvas","pageCtx","w","h","domToImage","_PdfGenerator","callback","error","opts","offsetWidth","offsetHeight","scaleObj","classList","tag","A4_WIDTH","A4_HEIGHT","compression","filename","output","pdf","jsPDF","pxFullHeight","page","pageHeight","imgData","PdfGenerator","domToPdf","domContainer","result","index_default"],"mappings":"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","file":"index.mjs","sourcesContent":["import { ElementOptions, ElementStyle } from '../types';\n\n/**\n * Clone a DOM node\n * @param node The node to clone\n * @param javascriptEnabled Whether to enable JavaScript in the cloned node\n * @returns The cloned node\n */\nexport const cloneNode = (node: Node, javascriptEnabled = false): Node => {\n  let child: Node | null;\n  let clone: Node;\n  \n  clone = node.nodeType === 3 \n    ? document.createTextNode((node as Text).nodeValue || '') \n    : (node as Element).cloneNode(false);\n  \n  child = node.firstChild;\n  \n  while (child) {\n    if (javascriptEnabled === true || child.nodeType !== 1 || (child as Element).nodeName !== 'SCRIPT') {\n      clone.appendChild(cloneNode(child, javascriptEnabled));\n    }\n    child = child.nextSibling;\n  }\n  \n  if (node.nodeType === 1) {\n    if ((node as Element).nodeName === 'CANVAS') {\n      const canvas = node as HTMLCanvasElement;\n      const cloneCanvas = clone as HTMLCanvasElement;\n      cloneCanvas.width = canvas.width;\n      cloneCanvas.height = canvas.height;\n      cloneCanvas.getContext('2d')?.drawImage(canvas, 0, 0);\n    } else if ((node as Element).nodeName === 'TEXTAREA' || (node as Element).nodeName === 'SELECT') {\n      (clone as HTMLTextAreaElement | HTMLSelectElement).value = (node as HTMLTextAreaElement | HTMLSelectElement).value;\n    }\n    \n    clone.addEventListener('load', () => {\n      (clone as Element).scrollTop = (node as Element).scrollTop;\n      (clone as Element).scrollLeft = (node as Element).scrollLeft;\n    }, true);\n  }\n  \n  return clone;\n};\n\n/**\n * Create an element with the given properties\n * @param tagName The tag name of the element to create\n * @param options The options for the element\n * @returns The created element\n */\nexport const createElement = (tagName: string, options: ElementOptions = {}): HTMLElement => {\n  const { className, innerHTML, style } = options;\n  const el = document.createElement(tagName);\n  \n  if (className) {\n    el.className = className;\n  }\n  \n  if (innerHTML) {\n    el.innerHTML = innerHTML;\n    const scripts = el.getElementsByTagName('script');\n    let i = scripts.length;\n    \n    while (i-- > 0) {\n      scripts[i].parentNode?.removeChild(scripts[i]);\n    }\n  }\n  \n  if (style) {\n    applyStyles(el, style);\n  }\n  \n  return el;\n};\n\n/**\n * Apply styles to an element\n * @param element The element to apply styles to\n * @param styles The styles to apply\n */\nexport const applyStyles = (element: HTMLElement, styles: ElementStyle): void => {\n  Object.keys(styles).forEach(key => {\n    element.style[key as any] = styles[key];\n  });\n};\n\n/**\n * Remove elements by class name\n * @param container The container element\n * @param classNames The class names to remove\n */\nexport const removeElementsByClassName = (container: HTMLElement, classNames: string[]): void => {\n  classNames.forEach(className => {\n    container.querySelectorAll(`.${className}`).forEach(el => el.remove());\n  });\n};\n\n/**\n * Remove elements by tag name\n * @param container The container element\n * @param tagNames The tag names to remove\n */\nexport const removeElementsByTagName = (container: HTMLElement, tagNames: string[]): void => {\n  tagNames.forEach(tagName => {\n    const elements = container.getElementsByTagName(tagName);\n    \n    for (let i = elements.length - 1; i >= 0; i--) {\n      if (elements[i]) {\n        elements[i].parentNode?.removeChild(elements[i]);\n      }\n    }\n  });\n};","import { createElement } from './dom';\nimport { PageBreakRules } from '../types';\n\n/**\n * Handle page break for an element\n * @param element The element to handle page break for\n * @param pageHeightPx The height of a page in pixels\n */\nexport const handlePageBreak = (element: Element, pageHeightPx: number): void => {\n  const rules: PageBreakRules = {\n    before: false,\n    after: false,\n    avoid: true\n  };\n  \n  const clientRect = element.getBoundingClientRect();\n  \n  if (rules.avoid && !rules.before) {\n    const startPage = Math.floor(clientRect.top / pageHeightPx);\n    const endPage = Math.floor(clientRect.bottom / pageHeightPx);\n    const nPages = Math.abs(clientRect.bottom - clientRect.top) / pageHeightPx;\n    \n    // Turn on rules.before if the element is broken and is at most one page long\n    if (endPage !== startPage && nPages <= 1) {\n      rules.before = true;\n    }\n    \n    // Before: Create a padding div to push the element to the next page\n    if (rules.before) {\n      const pad = createElement('div', {\n        style: {\n          display: 'block',\n          height: `${pageHeightPx - (clientRect.top % pageHeightPx)}px`\n        }\n      });\n      \n      element.parentNode?.insertBefore(pad, element);\n    }\n  }\n};","import { removeElementsByClassName, removeElementsByTagName, createElement, cloneNode } from '../utils/dom';\nimport { handlePageBreak } from '../utils/pageBreaks';\nimport { DomToPdfOptions } from '../types';\n\n/**\n * Creates and manages the container for DOM-to-PDF conversion\n */\nexport class DomContainer {\n  private container: HTMLElement;\n  private overlay: HTMLElement;\n  private originalElement: HTMLElement;\n  private options: Required<Pick<DomToPdfOptions, 'excludeClassNames' | 'excludeTagNames' | 'overrideWidth'>>;\n  private pageHeightPx: number;\n  \n  private static readonly A4_HEIGHT = 841.89;\n  private static readonly A4_WIDTH = 595.28;\n  \n  /**\n   * Create a new DomContainer\n   * @param element The element to convert to PDF\n   * @param options The options for conversion\n   */\n  constructor(element: HTMLElement, options: DomToPdfOptions = {}) {\n    this.originalElement = element;\n    this.options = {\n      excludeClassNames: options.excludeClassNames || [],\n      excludeTagNames: options.excludeTagNames || ['button', 'input', 'select'],\n      overrideWidth: options.overrideWidth || 0\n    };\n    \n    const { overlay, container } = this.createOverlayAndContainer();\n    this.overlay = overlay;\n    this.container = container;\n    \n    // Calculate page height\n    const innerRatio = DomContainer.A4_HEIGHT / DomContainer.A4_WIDTH;\n    const containerWidth = this.options.overrideWidth || this.container.getBoundingClientRect().width;\n    this.pageHeightPx = Math.floor(containerWidth * innerRatio);\n    \n    // Setup the container\n    this.setupContainer();\n  }\n  \n  /**\n   * Get the container element\n   * @returns The container element\n   */\n  public getContainer(): HTMLElement {\n    return this.container;\n  }\n  \n  /**\n   * Get the overlay element\n   * @returns The overlay element\n   */\n  public getOverlay(): HTMLElement {\n    return this.overlay;\n  }\n  \n  /**\n   * Get the page height in pixels\n   * @returns The page height in pixels\n   */\n  public getPageHeightPx(): number {\n    return this.pageHeightPx;\n  }\n  \n  /**\n   * Remove the overlay from the document\n   */\n  public remove(): void {\n    document.body.removeChild(this.overlay);\n  }\n  \n  /**\n   * Create the overlay and container elements\n   * @returns The overlay and container elements\n   */\n  private createOverlayAndContainer(): { overlay: HTMLElement, container: HTMLElement } {\n    // Create overlay styles\n    const overlayStyle: Record<string, string> = {\n      position: 'fixed',\n      zIndex: '1000',\n      opacity: '0',\n      left: '0',\n      right: '0',\n      bottom: '0',\n      top: '0',\n      backgroundColor: 'rgba(0,0,0,0.8)'\n    };\n    \n    if (this.options.overrideWidth) {\n      overlayStyle.width = `${this.options.overrideWidth}px`;\n    }\n    \n    // Create container styles\n    const containerStyle: Record<string, string> = {\n      position: 'absolute',\n      left: '0',\n      right: '0',\n      top: '0',\n      height: 'auto',\n      margin: 'auto',\n      overflow: 'auto',\n      backgroundColor: 'white'\n    };\n    \n    // Create elements\n    const overlay = createElement('div', { style: overlayStyle });\n    const container = createElement('div', { style: containerStyle });\n    \n    // Append cloned element to container\n    container.appendChild(cloneNode(this.originalElement) as Node);\n    overlay.appendChild(container);\n    document.body.appendChild(overlay);\n    \n    return { overlay, container };\n  }\n  \n  /**\n   * Setup the container for PDF generation\n   */\n  private setupContainer(): void {\n    // Remove excluded elements\n    this.removeExcludedElements();\n    \n    // Handle page breaks\n    this.handlePageBreaks();\n  }\n  \n  /**\n   * Remove excluded elements from the container\n   */\n  private removeExcludedElements(): void {\n    const { excludeClassNames, excludeTagNames } = this.options;\n    \n    removeElementsByClassName(this.container, excludeClassNames);\n    removeElementsByTagName(this.container, excludeTagNames);\n  }\n  \n  /**\n   * Handle page breaks for elements in the container\n   */\n  private handlePageBreaks(): void {\n    const elements = this.container.querySelectorAll('*');\n    \n    Array.from(elements).forEach(element => {\n      handlePageBreak(element, this.pageHeightPx);\n    });\n  }\n}","/**\n * Check if canvas is blank\n * @param canvas The canvas to check\n * @returns Whether the canvas is blank\n */\nexport const isCanvasBlank = (canvas: HTMLCanvasElement): boolean => {\n  const blank = document.createElement('canvas');\n  blank.width = canvas.width;\n  blank.height = canvas.height;\n  const ctx = blank.getContext('2d');\n  \n  if (ctx) {\n    ctx.fillStyle = '#FFFFFF';\n    ctx.fillRect(0, 0, blank.width, blank.height);\n  }\n  \n  return canvas.toDataURL() === blank.toDataURL();\n};\n\n/**\n * Draw a page of the PDF from the source canvas\n * @param sourceCanvas The source canvas\n * @param pageNumber The page number\n * @param pageCanvas The canvas for the page\n * @param pageHeightPx The height of the page in pixels\n * @returns Whether the page is blank\n */\nexport const drawPdfPage = (\n  sourceCanvas: HTMLCanvasElement,\n  pageNumber: number,\n  pageCanvas: HTMLCanvasElement,\n  pageHeightPx: number\n): boolean => {\n  const pageCtx = pageCanvas.getContext('2d');\n  \n  if (!pageCtx) {\n    throw new Error('Could not get canvas context');\n  }\n  \n  const w = pageCanvas.width;\n  const h = pageCanvas.height;\n  \n  pageCtx.fillStyle = 'white';\n  pageCtx.fillRect(0, 0, w, h);\n  pageCtx.drawImage(sourceCanvas, 0, pageNumber * pageHeightPx, w, h, 0, 0, w, h);\n  \n  return !isCanvasBlank(pageCanvas);\n};","import { jsPDF } from 'jspdf';\nimport { drawPdfPage } from '../utils/canvas';\nimport { DomToPdfCallback, DomToPdfOptions, FilterElement, PdfResult } from '../types';\n\n// Use require instead of import for dom-to-image to avoid type issues\nconst domToImage = require('dom-to-image');\n\n/**\n * PDF Generator class that handles PDF creation\n */\nexport class PdfGenerator {\n  private static readonly A4_HEIGHT = 841.89;\n  private static readonly A4_WIDTH = 595.28;\n  \n  private options: Required<DomToPdfOptions>;\n  private container: HTMLElement;\n  private callback?: DomToPdfCallback;\n  \n  /**\n   * Create a new PdfGenerator\n   * @param container The container element to generate PDF from\n   * @param options The options for PDF generation\n   * @param callback The callback to call when PDF is generated\n   */\n  constructor(container: HTMLElement, options: DomToPdfOptions = {}, callback?: DomToPdfCallback) {\n    this.container = container;\n    this.callback = callback;\n    \n    // Set default options\n    this.options = {\n      filename: options.filename || 'generated.pdf',\n      excludeClassNames: options.excludeClassNames || [],\n      excludeTagNames: options.excludeTagNames || ['button', 'input', 'select'],\n      overrideWidth: options.overrideWidth || 0,\n      proxyUrl: options.proxyUrl || '',\n      compression: options.compression || 'NONE',\n      scale: options.scale || 0,\n      output: options.output || 'pdf'\n    };\n  }\n  \n  /**\n   * Generate the PDF from the container\n   * @returns A promise that resolves to the PDF result\n   */\n  public async generate(): Promise<PdfResult> {\n    try {\n      const canvas = await this.generateCanvas();\n      return this.generatePdfFromCanvas(canvas);\n    } catch (error) {\n      if (this.callback) {\n        this.callback(null);\n      }\n      console.error(error);\n      return null;\n    }\n  }\n  \n  /**\n   * Generate a canvas from the container\n   * @returns A promise that resolves to the canvas\n   */\n  private async generateCanvas(): Promise<HTMLCanvasElement> {\n    const opts = this.createDomToImageOptions();\n    return domToImage.toCanvas(this.container, opts);\n  }\n  \n  /**\n   * Create options for dom-to-image\n   * @returns The options for dom-to-image\n   */\n  private createDomToImageOptions(): any {\n    const opts: any = {\n      filter: this.createFilterFunction(),\n      proxy: this.options.proxyUrl\n    };\n    \n    if (this.options.scale) {\n      const offsetWidth = this.container.offsetWidth;\n      const offsetHeight = this.container.offsetHeight;\n      \n      const style = {\n        transform: `scale(${this.options.scale})`,\n        transformOrigin: 'top left',\n        width: `${offsetWidth}px`,\n        height: `${offsetHeight}px`\n      };\n      \n      const scaleObj = {\n        width: offsetWidth * this.options.scale,\n        height: offsetHeight * this.options.scale,\n        quality: 1,\n        style\n      };\n      \n      Object.assign(opts, scaleObj);\n    }\n    \n    return opts;\n  }\n  \n  /**\n   * Create a filter function for dom-to-image\n   * @returns The filter function\n   */\n  private createFilterFunction(): (element: FilterElement) => boolean {\n    const { excludeClassNames, excludeTagNames } = this.options;\n    \n    return ({ classList, tagName }: FilterElement): boolean => {\n      if (classList) {\n        for (const className of excludeClassNames) {\n          if (Array.prototype.indexOf.call(classList, className) >= 0) {\n            return false;\n          }\n        }\n      }\n      \n      const tag = tagName?.toLowerCase();\n      return tag ? excludeTagNames.indexOf(tag) < 0 : true;\n    };\n  }\n  \n  /**\n   * Generate a PDF from a canvas\n   * @param canvas The canvas to generate PDF from\n   * @returns The PDF result\n   */\n  private generatePdfFromCanvas(canvas: HTMLCanvasElement): PdfResult {\n    const { A4_WIDTH, A4_HEIGHT } = PdfGenerator;\n    const { compression, filename, output } = this.options;\n    \n    // Calculate container dimensions\n    const containerWidth = this.options.overrideWidth || this.container.getBoundingClientRect().width;\n    const pageHeightPx = Math.floor(containerWidth * (A4_HEIGHT / A4_WIDTH));\n    \n    // Initialize the PDF\n    const pdf = new jsPDF({\n      orientation: 'p',\n      unit: 'pt',\n      format: 'a4'\n    });\n    \n    // Calculate pages\n    const pxFullHeight = canvas.height;\n    const nPages = Math.ceil(pxFullHeight / pageHeightPx);\n    \n    // Page canvas for drawing each page\n    const pageCanvas = document.createElement('canvas');\n    pageCanvas.width = canvas.width;\n    pageCanvas.height = pageHeightPx;\n    \n    // Process each page\n    for (let page = 0; page < nPages; page++) {\n      // Adjust height for last page if needed\n      let pageHeight = A4_HEIGHT;\n      \n      if (page === nPages - 1 && pxFullHeight % pageHeightPx !== 0) {\n        pageCanvas.height = pxFullHeight % pageHeightPx;\n        pageHeight = (pageCanvas.height * A4_WIDTH) / pageCanvas.width;\n      }\n      \n      // Draw page and skip if blank\n      const isNotBlank = drawPdfPage(canvas, page, pageCanvas, pageHeightPx);\n      \n      if (!isNotBlank) {\n        continue;\n      }\n      \n      // Add new page if not the first page\n      if (page > 0) {\n        pdf.addPage();\n      }\n      \n      // Add image to PDF\n      const imgData = pageCanvas.toDataURL('image/PNG');\n      pdf.addImage(imgData, 'PNG', 0, 0, A4_WIDTH, pageHeight, undefined, compression);\n    }\n    \n    // Call callback if provided\n    if (this.callback) {\n      this.callback(pdf);\n    }\n    \n    // Handle different output formats\n    if (output === 'blob') {\n      return pdf.output('blob');\n    }\n    \n    if (output === 'base64') {\n      return pdf.output('datauristring');\n    }\n    \n    if (output === 'pdf') {\n      return pdf.save(filename);\n    }\n    \n    return pdf;\n  }\n}","import { DomContainer } from './core/DomContainer';\nimport { PdfGenerator } from './core/PdfGenerator';\nimport { DomToPdfCallback, DomToPdfOptions, PdfResult } from './types';\n\n/**\n * Generate a PDF from a DOM element\n * @param element The element to generate PDF from\n * @param options The options for PDF generation\n * @param callback Optional callback function that receives the generated PDF\n * @returns A promise that resolves to the generated PDF\n */\nconst domToPdf = async (\n  element: HTMLElement,\n  options: DomToPdfOptions = {},\n  callback?: DomToPdfCallback\n): Promise<PdfResult> => {\n  try {\n    // Create container\n    const domContainer = new DomContainer(element, options);\n    \n    // Generate PDF\n    const pdfGenerator = new PdfGenerator(domContainer.getContainer(), options, callback);\n    const result = await pdfGenerator.generate();\n    \n    // Clean up\n    domContainer.remove();\n    \n    return result;\n  } catch (error) {\n    console.error('Error generating PDF:', error);\n    if (callback) {\n      callback(null);\n    }\n    return null;\n  }\n};\n\nexport default domToPdf;\nexport { domToPdf };\nexport * from './types';\nexport * from './utils/dom';\nexport * from './utils/canvas';\nexport * from './core/PdfGenerator';\nexport * from './core/DomContainer';"]}